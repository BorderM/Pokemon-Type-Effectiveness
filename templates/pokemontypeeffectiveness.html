<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            html,
            body {
                height: 100%;
                margin: 0;
                background: #0e131f; /* same as header */
            }
            /* Progress bar */
            @keyframes progress {
                0% {
                    width: 0;
                }
                100% {
                    width: 100%;
                }
            }
            .progress-bar {
                width: 100%;
                height: 10px;
                border-radius: 9999px;
                background: #3b82f6;
                animation: progress 2s linear infinite;
            }
            .hidden {
                display: none !important;
            }

            /* Fixed header */
            header {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: #1f2937; /* gray-800 */
                padding: 1rem 0;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                align-items: center;
                height: 200px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            }
            .watermark-fixed {
                position: absolute;
                top: 10px;
                left: 10px;
                font-size: 0.75rem;
                color: #a0aec0;
            }

            /* Controls */
            .control-buttons {
                display: flex;
                gap: 10px;
                margin-bottom: 10px;
            }

            /* Input + suggestions */
            .input-container {
                position: relative;
                width: 100%;
                max-width: 450px;
            }
            .input-field {
                width: 100%;
                padding: 8px;
                border: none;
                border-radius: 4px;
                background: #374151; /* gray-700 – contrast vs header */
                color: #fff;
            }
            .suggestions {
                position: absolute;
                top: 100%;
                left: 0;
                width: 100%;
                background: #fff;
                color: #000;
                border: 1px solid #ccc;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                display: none;
                z-index: 1001;
                margin-top: 2px;
            }
            .suggestions li {
                list-style: none;
                padding: 8px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
            }
            .suggestions li:last-child {
                border-bottom: none;
            }
            .suggestions li.highlighted,
            .suggestions li:hover {
                background: #BFC2BA;
            }

            /* ─── container / history / main-result ─── */
            .container {
                position: relative;
                max-width: 1200px;
                margin: 0 auto;
                padding-top: 220px; /* keep space for the header */
                border-top: 1px solid #374151; /* dark grey separator */
                background: #0e131f; /* your original gray-900 */
                display: flex;
                gap: 2rem;
            }
            /* hide history until you push your first item */
            #history:empty {
                display: none;
            }
            /* once it has items, float it on top of the left edge */
            #history {
                background: #1f2937; /* same as your main card bg */
                padding: 1rem; /* give it some breathing room */
                width: 180px;
                max-height: calc(100vh - 240px);
                overflow-y: auto;
                padding-right: 1rem;
                border-right: 1px solid #374151;
            }
            /* history cards */
            .small-card {
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: #374151; /* slightly lighter */
                color: #fff;
                padding: 0.25rem 0.5rem;
                margin-bottom: 0.25rem;
                font-size: 0.875rem;
                width: 100%;
                box-sizing: border-box;
            }

            .small-card .history-btn {
                background: transparent;
                border: none;
                color: white;
                text-align: left; /* label flush left */
                flex: 1; /* fill the remaining space */
                padding: 0.25rem 0; /* vertical hit-area */
                font-size: 0.875rem;
                cursor: pointer;
            }

            /* give the “×” a pop of color */
            .small-card .remove-btn {
                background: #ef4444;
                color: white;
                border: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.75rem;
                line-height: 1;
                cursor: pointer;
            }
            .small-card:hover {
                background: #374151;
            }
            .mode-toggle-container {
              margin-top: 0.5rem;
              display: flex;
              justify-content: center;
            }

            /* main-result grows to fill the rest of the flex container */
            #main-result {
                position: absolute;
                top: 220px;
                left: 50%;
                transform: translateX(-50%);
                width: max-content;
                min-height: calc(100vh - 260px);
                display: flex;
                justify-content: center;
                align-items: flex-start;
                z-index: 0;
                gap: 1rem;
            }
            /* ───── result-card (original size & aesthetic) ───── */
            .result-card {
                background: #1f2937; /* gray-800 */
                color: white;
                position: relative;
                padding: 1rem;
                border-radius: 0.5rem;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                max-width: 500px;
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                /* let it grow naturally—no forced max-height/scroll */
            }
            .close-button {
                position: absolute;
                top: 10px;
                right: 10px;
                background: #ef4444; /* red-500 */
                color: white;
                border: none;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                cursor: pointer;
            }
            .result-card img {
                width: 100px;
                height: 100px;
            }
            .result-card h2 {
                margin: 0;
                font-size: 1.25rem;
                font-weight: 700;
                text-align: center;
                text-transform: capitalize;
            }
            .result-card p.type-line {
                margin: 0.5rem 0 1rem;
                font-weight: 600;
                text-align: center;
            }

            /* Type badges */
            .type-badge {
                display: inline-block;
                padding: 0.25rem 0.5rem;
                border-radius: 0.3rem;
                color: #fff;
                font-weight: bold;
                margin: 0.2rem;
                text-transform: capitalize;
            }
            .type-normal {
                background: #A8A77A;
            }
            .type-fire {
                background: #EE8130;
            }
            .type-water {
                background: #6390F0;
            }
            .type-electric {
                background: #F7D02C;
            }
            .type-grass {
                background: #7AC74C;
            }
            .type-ice {
                background: #96D9D6;
            }
            .type-fighting {
                background: #C22E28;
            }
            .type-poison {
                background: #A33EA1;
            }
            .type-ground {
                background: #E2BF65;
            }
            .type-flying {
                background: #A98FF3;
            }
            .type-psychic {
                background: #F95587;
            }
            .type-bug {
                background: #A6B91A;
            }
            .type-rock {
                background: #B6A136;
            }
            .type-ghost {
                background: #735797;
            }
            .type-dragon {
                background: #6F35FC;
            }
            .type-dark {
                background: #705746;
            }
            .type-steel {
                background: #C0C0C0;
            }
            .type-fairy {
                background: #D685AD;
            }
            .type-none {
                background: #4B5563;
            }

            .separator {
                width: 100%;
                height: 1px;
                background: #374151;
                margin: 1rem 0;
                margin: 0.5rem;
            }
            .effectiveness-row {
                display: flex;
                width: 100%;
                align-items: flex-start;
            }
            .effectiveness-label {
                width: 100px;
                font-weight: bold;
                text-transform: capitalize;
            }
            .effectiveness-content {
                flex: 1;
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            /* Error message */
            .error-message-fixed {
                position: absolute;
                top: 80px;
                left: 10px;
                right: 10px;
                z-index: 1001;
            }
        </style>
        <title>Pokémon Type Effectiveness</title>
    </head>
    <body>
        <header>
            <div class="watermark-fixed">Created by BorderM</div>
            <h1 class="text-3xl font-bold mb-2">Pokémon Type Effectiveness</h1>
            <div class="control-buttons">
                <button onclick="performSearch()"class="bg-blue-500 text-white p-2 rounded">Search</button>
                <button onclick="clearHistory()"class="bg-gray-500 text-white p-2 rounded">Clear</button>
                <a href="/stats"class="bg-yellow-500 text-white p-2 rounded">Stats</a>
                <a href="/typecalculator"class="bg-red-500 text-white p-2 rounded">Type Calcs</a>
                <a href="/natures"class="bg-cyan-500 text-white p-2 rounded">Natures</a>
                <a href="/evolutions"class="bg-orange-500 text-white p-2 rounded">Evolutions</a>
            </div>
            <div class="input-container">
                <input
                    id="pokemon-input"
                    class="input-field"
                    placeholder="Enter Pokémon Name"
                    oninput="handleInput(event)"
                    onkeydown="handleEnterKey(event)"
                />
                <ul id="suggestions" class="suggestions"></ul>
            </div>
            <div class="mode-toggle-container">
              <button id="toggle-mode-btn" class="bg-indigo-500 text-white p-2 rounded">2v2</button>
            </div>
            <div id="progress-bar-container" class="hidden">
                <div class="progress-bar"></div>
            </div>
            <div id="error-message" class="error-message-fixed"></div>
        </header>

        <div class="container">
            <aside id="history"></aside>
            <section id="main-result"></section>
        </div>

        <script>

              // — state & persistence —
              let historyList = [];
              let currentPokemon = null;
              // when false: 1v1 mode (single card). when true: 2v2 mode (two cards)
              let dualMode = false;

              function saveState() {
                localStorage.setItem('pkmnHistory', JSON.stringify(historyList));
                localStorage.setItem('pkmnCurrent', JSON.stringify(currentPokemon));
                localStorage.setItem('pkmnDualMode', JSON.stringify(dualMode));
                // In 2v2 mode, also remember the right‐hand card
                if (dualMode) {
                  const secEl = document.getElementById('main-result');
                  if (secEl.children.length > 1) {
                    const secData = JSON.parse(secEl.children[1].dataset.pokemon);
                    localStorage.setItem('pkmnSecondary', JSON.stringify(secData));
                  }
                } else {
                  localStorage.removeItem('pkmnSecondary');
                }
              }

              function loadState() {
                // 1) restory history
                const histRaw = localStorage.getItem('pkmnHistory')
                if (histRaw) {
                  historyList = JSON.parse(histRaw)
                  historyList.forEach(r => renderHistoryEntry(r))
                }
                
                // 2) restore dualMode flag & button text
                const dmRaw = localStorage.getItem('pkmnDualMode')
                if (dmRaw !== null) {
                  dualMode = JSON.parse(dmRaw)
                  document.getElementById('toggle-mode-btn').textContent = dualMode ? '1v1' : '2v2'
                }
                
                // 3) clear result area and draw cards in order
                const sec = document.getElementById('main-result')
                sec.innerHTML = ''

                // primary slot
                const curRaw = localStorage.getItem('pkmnCurrent')
                if (curRaw) {
                  currentPokemon = JSON.parse(curRaw)
                  const card1 = createCard(currentPokemon)
                  card1.dataset.name = currentPokemon.name
                  sec.appendChild(card1)
                }

                // secondary slot if in 2v2
                if (dualMode) {
                  const secRaw = localStorage.getItem('pkmnSecondary')
                  if (secRaw) {
                    const secondary = JSON.parse(secRaw)
                    const card2 = createCard(secondary)
                    card2.dataset.name = secondary.name
                    sec.appendChild(card2)
                  }
                }
              } 

              // — scrolling helper —
              const HEADER_HEIGHT = document.querySelector('header').offsetHeight;
              function scrollWithGap(el) {
                const y = el.getBoundingClientRect().top + window.scrollY;
                window.scrollTo({ top: y - HEADER_HEIGHT - 16, behavior: 'smooth' });
              }

              // — render the main result card —
              function renderMainCard(r) {
                currentPokemon = r;
                saveState();
                const sec = document.getElementById('main-result');
                // in single‐mode we clear; in dual‐mode we just append (and later evict if >2)
                if (!dualMode) {
                sec.innerHTML = '';
                }
                const card = createCard(r);
                card.dataset.name = r.name;
                sec.appendChild(card);
                // ensure at most 2 cards side‐by‐side
                if (dualMode && sec.children.length > 2) {
                sec.removeChild(sec.children[0]);
                }
                scrollWithGap(card);
              }

              // — when you click a history entry —
              function swapToMain(r) {
                // 1) remove the clicked one from history
                removeHistoryEntry(r.name);
                
                const sec = document.getElementById('main-result')
                // 2v2 mode: replace the right card
                if (dualMode) {
                  if (sec.children.length === 0) {
                    renderMainCard(r);
                  } else if (sec.children.length === 1) {
                    //just append as second
                    const card = createCard(r);
                    card.dataset.name = r.name;
                    sec.appendChild(card);
                  } else {
                    //two cards: move rightmose to history, then swap in new
                    const right = sec.children[1];
                    const data = JSON.parse(right.dataset.pokemon);
                    pushToHistory(data);
                    right.remove();
                    const card = createCard(r);
                    card.dataset.name = r.name;
                    sec.appendChild(card);
                  }
                }
                // 1v1 mode: Original swap order
                else {
                  if (currentPokemon && currentPokemon.name !== r.name) {
                    historyList.unshift(currentPokemon);
                    renderHistoryEntry(currentPokemon, true);
                  }
                  renderMainCard(r);
                }
                saveState();
              }

              // — render a single history button —
              function renderHistoryEntry(r, prepend = false) {
                // skip duplicates
                if (document.querySelector(`#history .small-card[data-name="${r.name}"]`)) return;

                const btn = document.createElement('div');
                btn.className = 'small-card';
                btn.dataset.name = r.name;
                btn.innerHTML = `
                  <button class="history-btn">
                    ${r.name.charAt(0).toUpperCase() + r.name.slice(1)}
                    </button>
                    <button class="remove-btn">×</button>
                `;

                // click on label → swap
                btn.querySelector('.history-btn').onclick = () => swapToMain(r);

                // click on × → just remove
                btn.querySelector('.remove-btn').onclick = e => {
                  e.stopPropagation();
                  removeHistoryEntry(r.name);
                };

                const container = document.getElementById('history');
                if (prepend && container.firstChild) {
                  container.insertBefore(btn, container.firstChild);
                } else {
                  container.appendChild(btn);
                }
              }

              function pushToHistory(r) {
                // skip if already in history or is current
                if (historyList.some(x => x.name === r.name)) {
                  return;
                }
                historyList.unshift(r);
                renderHistoryEntry(r, /*prepend=*/true);
                saveState();
              }

              function removeHistoryEntry(name) {
                historyList = historyList.filter(x => x.name !== name);
                const btn = document.querySelector(`#history .small-card[data-name="${name}"]`);
                if (btn) btn.remove();
                saveState();
              }

              function clearHistory() {
                historyList = [];
                currentPokemon = null;
                document.getElementById('history').innerHTML = '';
                document.getElementById('main-result').innerHTML = '';
                localStorage.removeItem('pkmnHistory');
                localStorage.removeItem('pkmnCurrent');
              }

              // — suggestions & search flow (unchanged) —
              let selectedIndex = -1;
              function handleInput(e) {
                const q = e.target.value.trim();
                const box = document.getElementById('suggestions');
                if (q.length > 1) {
                  fetch(`/api/pokemon/suggestions?query=${encodeURIComponent(q)}`)
                    .then(r=>r.json())
                    .then(data=>{
                      box.innerHTML = data.suggestions
                        .map(s=>`<li onclick="selectSuggestion('${s}')">${s}</li>`)
                        .join('');
                      box.style.display = data.suggestions.length ? 'block' : 'none';
                      selectedIndex = -1;
                    });
                } else {
                  box.style.display = 'none';
                  box.innerHTML = '';
                }
              }
              function handleEnterKey(e) {
                const box = document.getElementById('suggestions');
                const items = Array.from(box.querySelectorAll('li'));
                if (e.key==='ArrowDown'||e.key==='ArrowUp') {
                  e.preventDefault();
                  selectedIndex += e.key==='ArrowDown'?1:-1;
                  selectedIndex = Math.max(0, Math.min(items.length-1, selectedIndex));
                  items.forEach((li,i)=>li.classList.toggle('highlighted', i===selectedIndex));
                }
                else if (e.key==='Enter') {
                  e.preventDefault();
                  if (items.length) {
                    const idx = selectedIndex>=0?selectedIndex:0;
                    selectSuggestion(items[idx].textContent);
                  } else {
                    performSearch();
                  }
                  box.style.display='none';
                }
              }
              function selectSuggestion(name) {
                document.getElementById('pokemon-input').value = name;
                document.getElementById('suggestions').style.display='none';
                performSearch();
              }

              function performSearch() {
                const inp = document.getElementById('pokemon-input');
                let name  = inp.value.trim();
                const items = document.querySelectorAll('#suggestions li');
                if (!name && items.length) name = items[0].textContent;
                if (!name) return;
                document.getElementById('suggestions').style.display='none';
                document.getElementById('progress-bar-container').classList.remove('hidden');
                fetchPokemon(name.toLowerCase())
                  .finally(() => {
                    document.getElementById('progress-bar-container').classList.add('hidden');
                    inp.value=''; inp.focus();
                  });
              }

              async function fetchPokemon(name) {
                const sec = document.getElementById('main-result');

                // — if it’s already showing as the main card, just scroll to it —
                if (currentPokemon && currentPokemon.name === name && !dualMode) {
                  scrollWithGap(sec.querySelector(`.result-card[data-name="${name}"]`));
                  return;
                }

                // — 2v2 MODE: sliding‐window of 2 cards —
                if (dualMode) {
                  // 1) Fetch the data
                  const ep   = location.pathname.includes('stats') ? 'stats' : 'info';
                  const res  = await fetch(`/api/pokemon/${ep}?name=${encodeURIComponent(name)}`);
                  const data = await res.json();
                  document.getElementById('error-message').innerHTML = '';

                  if (!res.ok) {
                    // Show error and bail
                    document.getElementById('error-message').innerHTML =
                      `<div class="bg-red-600 text-white p-2 rounded">${data.error}</div>`;
                    return;
                  }
                  const r = data[0];

                  // 2) Zero cards yet → show first slot only
                  if (sec.children.length === 0) {
                    renderMainCard(r);
                    return;
                  }

                  // 3) One card → append as the second (if not duplicate)
                  if (sec.children.length === 1) {
                    if (sec.children[0].dataset.name !== r.name) {
                      const card = createCard(r);
                      card.dataset.name = r.name;
                      sec.appendChild(card);
                      saveState();
                    }
                    return;
                  }

                  // 4) Two cards: slide window
                  //    a) move leftmost into history
                  {
                    const leftCard = sec.children[0];
                    const leftData = JSON.parse(leftCard.dataset.pokemon);
                    pushToHistory(leftData);
                    sec.removeChild(leftCard);
                  }
                  //    b) append new one (if not same as the remaining)
                  if (sec.children[0].dataset.name !== r.name) {
                    const card = createCard(r);
                    card.dataset.name = r.name;
                    sec.appendChild(card);
                  }
                  const newPrimary = JSON.parse(sec.children[0].dataset.pokemon);
                  currentPokemon = newPrimary;
                  saveState();
                  return;
                }

                // — 1v1 MODE: original single-card behavior —
                // push the old main into history, if there is one
                if (currentPokemon) {
                  pushToHistory(currentPokemon);
                }

                // fetch & render the new one
                const epSingle   = location.pathname.includes('stats') ? 'stats' : 'info';
                const resSingle  = await fetch(`/api/pokemon/${epSingle}?name=${encodeURIComponent(name)}`);
                const dataSingle = await resSingle.json();
                document.getElementById('error-message').innerHTML = '';

                if (resSingle.ok) {
                  const r = dataSingle[0];
                  // remove from history (in case it was there)
                  removeHistoryEntry(r.name);
                  // render single slot
                  renderMainCard(r);
                } else {
                  document.getElementById('error-message').innerHTML =
                    `<div class="bg-red-600 text-white p-2 rounded">${dataSingle.error}</div>`;
                }
              }


              function createCard(r) {
                const d = document.createElement('div');
                d.className = 'result-card';
                d.dataset.pokemon = JSON.stringify(r);
                d.innerHTML = `
                  <button class="close-button" onclick="closeCard(this)">×</button>
                  <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${r.id}.png" alt="${r.name}">
                  <h2>${r.name}</h2>
                  <p class="type-line">Type: ${r.types.map(
                    t=>`<span class="type-badge type-${t.toLowerCase()}">${t}</span>`
                  ).join(' ')}</p>
                  <div class="separator"></div>
                  ${renderRow('4x Weak', r.effectiveness.four_times_effective)}
                  <div class="separator"></div>
                  ${renderRow('2x Weak', r.effectiveness.super_effective)}
                  <div class="separator"></div>
                  ${renderRow('Normal', r.effectiveness.normal_effective)}
                  <div class="separator"></div>
                  ${renderRow('2x Resistant', r.effectiveness.two_times_resistant)}
                  <div class="separator"></div>
                  ${renderRow('4x Resistant', r.effectiveness.four_times_resistant)}
                  <div class="separator"></div>
                  ${renderRow('Immune', r.effectiveness.immune)}
                `;
                return d;
              }

              function renderRow(label, types) {
                const items = types.length
                  ? types.map(t=>`<span class="type-badge type-${t.toLowerCase()}">${t}</span>`).join(' ')
                  : `<span class="type-badge type-none">None</span>`;
                return `
                  <div class="effectiveness-row">
                    <span class="effectiveness-label">${label}:</span>
                    <div class="effectiveness-content">${items}</div>
                  </div>`;
              }
              function closeMainCard() {
                // 1) Wipe out the DOM
                const sec = document.getElementById('main-result');
                sec.innerHTML = '';
                // 2) Clear state & storage
                currentPokemon = null;
                localStorage.removeItem('pkmnCurrent');
                // 3) Persist everything (historyList + dualMode)
                saveState();
              }

              // — 1v1 ⇄ 2v2 toggle button handler —
              const toggleBtn = document.getElementById('toggle-mode-btn');
              toggleBtn.addEventListener('click', () => {
                const sec = document.getElementById('main-result');

                if (!dualMode) {
                  // switch into 2v2
                  dualMode = true;
                  toggleBtn.textContent = '1v1';
                  // auto-fill slot 2 from history if available
                  if (historyList.length > 0) {
                    const nextUp = historyList.shift();
                    removeHistoryEntry(nextUp.name);
                    renderMainCard(nextUp);
                  }
                } else {
                  // switch back to 1v1
                  dualMode = false;
                  toggleBtn.textContent = '2v2';

                  // if you had two cards, move the right one into history
                  if (sec.children.length > 1) {
                    const rightCard = sec.children[1];
                    const obj = JSON.parse(rightCard.dataset.pokemon);
                    removeHistoryEntry(obj.name);
                    historyList.unshift(obj);
                    renderHistoryEntry(obj, /*prepend=*/true);
                    rightCard.remove();
                  }
                  // then collapse down to exactly one card
                  if (sec.children.length > 0) {
                    const firstData = JSON.parse(sec.children[0].dataset.pokemon);
                    renderMainCard(firstData);
                  }
                }

                // Persist your new mode + history
                saveState();
              });

              function closeCard(btn) {
                const sec  = document.getElementById('main-result');
                const card = btn.closest('.result-card');
                // --- 1v1: identical to your old closeMainCard ---
                if (!dualMode) {
                  sec.innerHTML = '';
                  currentPokemon = null;
                  localStorage.removeItem('pkmnCurrent');
                  saveState();
                  return;
                }

                // --- 2v2: remove just this slot ---
                // find its index 0 or 1
                const idx = Array.prototype.indexOf.call(sec.children, card);
                card.remove();

                if (idx === 0) {
                  // left slot closed: right automatically shifts into left
                  // nothing else to do, DOM does that for us when we removed [0]
                }
                // if idx===1 then right slot closed: left remains as-is

                // --- now update our JS state & localStorage to reflect
                //     whatever is now in slot#0 (or none) and slot#1 (or none) ---
                if (sec.children.length >= 1) {
                  const newPrimary = JSON.parse(sec.children[0].dataset.pokemon);
                  currentPokemon = newPrimary;
                  localStorage.setItem('pkmnCurrent', JSON.stringify(newPrimary));
                } else {
                  currentPokemon = null;
                  localStorage.removeItem('pkmnCurrent');
                }

                if (sec.children.length === 2) {
                  const newSecondary = JSON.parse(sec.children[1].dataset.pokemon);
                  localStorage.setItem('pkmnSecondary', JSON.stringify(newSecondary));
                } else {
                  localStorage.removeItem('pkmnSecondary');
                }

                // persist the rest of your state (history + dualMode)
                saveState();
              }

              window.addEventListener('DOMContentLoaded', loadState);
        </script>
    </body>
</html>
